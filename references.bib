@article{benton2005,
  title = {Embedded interpreters},
  volume = {15},
  DOI = {10.1017/S0956796804005398},
  number = {4},
  journal = {Journal of Functional Programming},
  publisher = {Cambridge University Press},
  author = {Benton, Nick},
  year = {2005},
  pages = {503–542},
}

@misc{grain2022,
  author = {Grain},
  title = {Grain: A strongly-typed functional programming language for the modern web.},
  note = {Retrieved June 08, 2022 from \url{https://grain-lang.org}},
  urldate = {2022-06-08},
  year = {2022},
}

@inproceedings{haas2017,
  address = {Barcelona Spain},
  title = {Bringing the web up to speed with {WebAssembly}},
  isbn = {978-1-4503-4988-8},
  url = {https://dl.acm.org/doi/10.1145/3062341.3062363},
  doi = {10.1145/3062341.3062363},
  language = {en},
  urldate = {2022-06-09},
  booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {
               Design} and {Implementation}},
  publisher = {ACM},
  author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman,
            Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, Jf},
  month = jun,
  year = {2017},
  pages = {185--200},
}

@article{herman2010,
  title = {Space-efficient gradual typing},
  author = {Herman, David and Tomb, Aaron and Flanagan, Cormac},
  journal = {Higher-Order and Symbolic Computation},
  volume = {23},
  number = {2},
  pages = {167--189},
  year = {2010},
  publisher = {Springer},
}

@inproceedings{kuhlenschmidt2019,
  author = {Kuhlenschmidt, Andre and Almahallawi, Deyaaeldeen and Siek, Jeremy G.},
  title = {Toward Efficient Gradual Typing for Structural Types via Coercions},
  year = {2019},
  isbn = {9781450367127},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3314221.3314627},
  doi = {10.1145/3314221.3314627},
  abstract = {Gradual typing combines static and dynamic typing in the same program. Siek et al.
              (2015) describe five criteria for gradually typed languages, including type soundness
              and the gradual guarantee. A significant number of languages have been developed in
              academia and industry that support some of these criteria (TypeScript, Typed Racket,
              Safe TypeScript, Transient Reticulated Python, Thorn, etc.) but relatively few support
              all the criteria (Nom, Gradualtalk, Guarded Reticulated Python). Of those that do, only
              Nom does so efficiently. The Nom experiment shows that one can achieve efficient
              gradual typing in languages with only nominal types, but many languages have structural
              types: function types, tuples, record and object types, generics, etc. In this paper we
              present a compiler, named Grift, that addresses the difficult challenge of efficient
              gradual typing for structural types. The input language includes a selection of
              difficult features: first- class functions, mutable arrays, and recursive types. We
              show that a close-to-the-metal implementation of run-time casts inspired by Henglein's
              coercions eliminates all of the catastrophic slowdowns without introducing significant
              average-case overhead. As a result, Grift exhibits lower overheads than those of Typed
              Racket. },
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and
               Implementation},
  pages = {517–532},
  numpages = {16},
  keywords = {compilation, efficiency, gradual typing},
  location = {Phoenix, AZ, USA},
  series = {PLDI 2019},
}

@article{new2018,
  author = {New, Max S. and Ahmed, Amal},
  title = {Graduality from Embedding-Projection Pairs},
  year = {2018},
  issue_date = {September 2018},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {2},
  number = {ICFP},
  url = {https://doi.org/10.1145/3236768},
  doi = {10.1145/3236768},
  abstract = {Gradually typed languages allow statically typed and dynamically typed code to
              interact while maintaining benefits of both styles. The key to reasoning about these
              mixed programs is Siek-Vitousek- Cimini-Boyland’s (dynamic) gradual guarantee, which
              says that giving components of a program more precise types only adds runtime type
              checking, and does not otherwise change behavior. In this paper, we give a semantic
              reformulation of the gradual guarantee called graduality. We change the name to promote
              the analogy that graduality is to gradual typing what parametricity is to polymorphism.
              Each gives a local-to-global, syntactic-to-semantic reasoning principle that is
              formulated in terms of a kind of observational approximation. Utilizing the analogy, we
              develop a novel logical relation for proving graduality. We show that
              embedding-projection pairs (ep pairs) are to graduality what relations are to
              parametricity. We argue that casts between two types where one is “more dynamic” (less
              precise) than the other necessarily form an ep pair, and we use this to cleanly prove
              the graduality cases for casts from the ep-pair property. To construct ep pairs, we
              give an analysis of the type dynamism relation—also known as type precision or naive
              subtyping—that interprets the rules for type dynamism as compositional constructions on
              ep pairs, analogous to the coercion interpretation of subtyping. },
  journal = {Proc. ACM Program. Lang.},
  month = {Jul},
  articleno = {73},
  numpages = {30},
  keywords = {gradual typing, logical relations, dynamic gradual guarantee, observational error
              approximation},
}

@inbook{nielson1999,
  author = "Nielson, Flemming and Nielson, Hanne Riis and Hankin, Chris",
  title = "Constraint Based Analysis",
  bookTitle = "Principles of Program Analysis",
  year = "1999",
  publisher = "Springer Berlin Heidelberg",
  address = "Berlin, Heidelberg",
  pages = "141--209",
  abstract = "In this chapter we present the technique of Constraint Based Analysis using a simple
              functional language, FUN. We begin by presenting an abstract specification of a Control
              Flow Analysis and then study its theoretical properties: it is correct with respect to
              a Structural Operational Semantics and it can be used to analyse all programs. This
              specification of the analysis does not immediately lend itself to an efficient
              algorithm for computing a solution so we proceed by developing first a syntax directed
              specification and then a constraint based formulation and finally we show how the
              constraints can be solved. We conclude by illustrating how the precision of the
              analysis can be improved by combining it with Data Flow Analysis and by incorporating
              context information thereby linking up with the development of the previous chapter.",
  isbn = "978-3-662-03811-6",
  doi = "10.1007/978-3-662-03811-6_3",
  url = "https://doi.org/10.1007/978-3-662-03811-6_3",
}
  
@article{omar2017,
  author = {Omar, Cyrus and Voysey, Ian and Hilton, Michael and Aldrich, Jonathan and Hammer,
            Matthew A.},
  title = {Hazelnut: A Bidirectionally Typed Structure Editor Calculus},
  year = {2017},
  issue_date = {January 2017},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {52},
  number = {1},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/3093333.3009900},
  doi = {10.1145/3093333.3009900},
  abstract = {Structure editors allow programmers to edit the tree structure of a program directly.
              This can have cognitive benefits, particularly for novice and end-user programmers. It
              also simplifies matters for tool designers, because they do not need to contend with
              malformed program text. This paper introduces Hazelnut, a structure editor based on a
              small bidirectionally typed lambda calculus extended with holes and a cursor. Hazelnut
              goes one step beyond syntactic well-formedness: its edit actions operate over
              statically meaningful incomplete terms. Naively, this would force the programmer to
              construct terms in a rigid "outside-in" manner. To avoid this problem, the action
              semantics automatically places terms assigned a type that is inconsistent with the
              expected type inside a hole. This meaningfully defers the type consistency check until
              the term inside the hole is finished. Hazelnut is not intended as an end-user tool
              itself. Instead, it serves as a foundational account of typed structure editing. To
              that end, we describe how Hazelnut's rich metatheory, which we have mechanized using
              the Agda proof assistant, serves as a guide when we extend the calculus to include
              binary sum types. We also discuss various interpretations of holes, and in so doing
              reveal connections with gradual typing and contextual modal type theory, the
              Curry-Howard interpretation of contextual modal logic. Finally, we discuss how
              Hazelnut's semantics lends itself to implementation as an event-based functional
              reactive program. Our simple reference implementation is written using js_of_ocaml. },
  journal = {SIGPLAN Not.},
  month = {Jan},
  pages = {86–99},
  numpages = {14},
  keywords = {gradual typing, structure editors, mechanized metatheory, bidirectional type systems},
}

@article{omar2019,
  author = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer, Matthew A.},
  title = {Live Functional Programming with Typed Holes},
  year = {2019},
  issue_date = {January 2019},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {POPL},
  url = {https://doi.org/10.1145/3290327},
  doi = {10.1145/3290327},
  abstract = {Live programming environments aim to provide programmers (and sometimes audiences)
              with continuous feedback about a program's dynamic behavior as it is being edited. The
              problem is that programming languages typically assign dynamic meaning only to programs
              that are complete, i.e. syntactically well-formed and free of type errors. Consequently
              , live feedback presented to the programmer exhibits temporal or perceptive gaps. This
              paper confronts this "gap problem" from type- theoretic first principles by developing
              a dynamic semantics for incomplete functional programs, starting from the static
              semantics for incomplete functional programs developed in recent work on Hazelnut. We
              model incomplete functional programs as expressions with holes, with empty holes
              standing for missing expressions or types, and non-empty holes operating as membranes
              around static and dynamic type inconsistencies. Rather than aborting when evaluation
              encounters any of these holes as in some existing systems, evaluation proceeds around
              holes, tracking the closure around each hole instance as it flows through the remainder
              of the program. Editor services can use the information in these hole closures to help
              the programmer develop and confirm their mental model of the behavior of the complete
              portions of the program as they decide how to fill the remaining holes. Hole closures
              also enable a fill-and-resume operation that avoids the need to restart evaluation
              after edits that amount to hole filling. Formally, the semantics borrows machinery from
              both gradual type theory (which supplies the basis for handling unfilled type holes)
              and contextual modal type theory (which supplies a logical basis for hole closures),
              combining these and developing additional machinery necessary to continue evaluation
              past holes while maintaining type safety. We have mechanized the metatheory of the core
              calculus, called Hazelnut Live, using the Agda proof assistant. We have also
              implemented these ideas into the Hazel programming environment. The implementation
              inserts holes automatically, following the Hazelnut edit action calculus, to guarantee
              that every editor state has some (possibly incomplete) type. Taken together with this
              paper's type safety property, the result is a proof-of-concept live programming
              environment where rich dynamic feedback is truly available without gaps, i.e. for every
              reachable editor state. },
  journal = {Proc. ACM Program. Lang.},
  month = {Jan},
  articleno = {14},
  numpages = {32},
  keywords = {live programming, typed holes, contextual modal type theory, structured editing,
              gradual typing},
}

@inproceedings{sabry1993,
  author = {Amr Sabry and Matthias Felleisen},
  title = {Reasoning about Programs in Continuation-Passing Style},
  booktitle = {LISP AND SYMBOLIC COMPUTATION},
  year = {1993},
  pages = {288--298},
  publisher = {},
}
